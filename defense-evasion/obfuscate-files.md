|||
|----|-----|
|**id**|mbc-123|
|**Name**|Executable Code Obfuscation|
|**Objective**|Anti-behavioral Analysis, Defense Evasion|
|**Related ATT&CK Technique(s)**|[Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027)|
|**Description**|Executable code can be obfuscated to hinder analysis. For example, code encryption (on disk and/or in memory); entry point, import address, or symbolic obfuscation; splitting code into rearranged sections connected by unconditional jumps, and merging all sections can make disassembly and static analysis more difficult.<br>A packer stub can generate polymorphic code on the fly, creating a file with the same functionality but different execution, making it difficult to detect.|
|**Methods**| <ul><li>Code Encryption: Encryption of the code in the malware instance in order to hinder static analysis.</li><li>Entry Point Obfuscation: Obfuscation of the entry point of the malware executable, in order to hinder static analysis.</li><li>Instruction Overlap: Jumping after the first byte of an instruction confuses some disassemblers.</li><li>Import Address Table Obfuscation: Obfuscation of the import address table of the malware instance, in order to hinder static analysis.</li><li>Symbolic Obfuscation: The removing or renaming of textual information in the code of the malware instance, in order to hinder static analysis.</li><li>Interleaving Code: A form of obfuscation that splits code into sections that are rearranged and connected by unconditional jumps, in order to hinder static analysis and disassembly.</li><li>Merged Code Sections: Merge all sections; just one entry in the sections table. Only affects readability slightly, so may not even be worth mitigating. May affect some detection signatures if written to be section dependent.</li><li>Import Compression: Imports are stored and loaded with a more compact import table format. Each DLL needed by the executable is mentioned in the IAT, but only one function from each/most is imported; the rest are imported "manually" via GetProcAddress calls.</li><li>Stack Strings: Strings are built and decrypted on the stack at each use, then discarded (to avoid obvious references).</li><li>Imports By Hash: Instead of calling GetProcAddress, a DLL is loaded and each export name is parsed until it matches a specific hash. This example is also known as GET_APIS_WITH_CRC. Also often seen used by shellcode, as it reduces the size of each import from a human-readable string to a sequence of four bytes.</li></ul>
|**Examples**|<ul><li>Ursnif: https://securityintelligence.com/news/banking-trojan-uses-malware-macros-to-evade-sandbox-detection/</li><li>Terminator: https://www.fireeye.com/content/dam/fireeye-www/current-threats/pdfs/pf/file/fireeye-hot-knives-through-butter.pdf</li><li>Kelihos: https://www.fireeye.com/content/dam/fireeye-www/current-threats/pdfs/pf/file/fireeye-hot-knives-through-butter.pdf</li><li>Rebhip: https://www.fireeye.com/blog/threat-research/2011/01/the-dead-giveaways-of-vm-aware-malware.html</li></ul>|

|||
|---------|------------------------|
|ID|B0001|
|Objective(s)|Anti-Static Analysis, Defense Evasion|
|Related ATT&CK Technique(s)|[Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027)|


Executable Code Obfuscation
===========================
Executable code can be obfuscated to hinder disassembly and static code analysis.

Methods
-------
* **Code Encryption**: Encryption of the code in the malware instance in order to hinder static analysis.
Entry Point Obfuscation: Obfuscation of the entry point of the malware executable, in order to hinder static analysis.
* **Instruction Overlap**: Jumping after the first byte of an instruction confuses some disassemblers.
Import Address Table Obfuscation: Obfuscation of the import address table of the malware instance, in order to hinder static analysis.
* **Symbolic Obfuscation**: The removing or renaming of textual information in the code of the malware instance, in order to hinder static analysis.
* **Interleaving Code**: A form of obfuscation that splits code into sections that are rearranged and connected by unconditional jumps, in order to hinder static analysis and disassembly.
* **Merged Code Sections**: Merge all sections; just one entry in the sections table. Only affects readability slightly, so may not even be worth mitigating. May affect some detection signatures if written to be section dependent.
* **Import Compression**: Imports are stored and loaded with a more compact import table format. Each DLL needed by the executable is mentioned in the IAT, but only one function from each/most is imported; the rest are imported "manually" via GetProcAddress calls.
* **Stack Strings**: Strings are built and decrypted on the stack at each use, then discarded (to avoid obvious references).
* **Imports By Hash**: Instead of calling GetProcAddress, a DLL is loaded and each export name is parsed until it matches a specific hash. This example is also known as GET_APIS_WITH_CRC. Also often seen used by shellcode, as it reduces the size of each import from a human-readable string to a sequence of four bytes.
* **Code Insertion**: Code insertion can impede disassembly.
   * *Dead Code Insertion*: Inclusion of "dead" code in the malware instance with no real functionality but with the intent of impeding disassembly.
   * *Fake Code Insertion*: Add fake code similar to known packers or known goods to fool identification. Can confuse some automated unpackers.
   * *Jump Insertion*: Insertion of jumps to make analysis visually harder.
   * *Junk Code Insertion*: Insertion of dummy code between relevant opcodes. Can make signature writing more complex.
   * *Thunk Code Insertion*: Variation on “jump”; also used by some compilers for user-generated functions (ex: Visual Studio /INCREMENTAL.

Malware Examples
----------------
|Name|Date|Description|
|-----------------------------|--------|-----------------------------|
|[**Geodo**](https://github.com/MAECProject/malware-behaviors/blob/master/xample-malware/geodo.md) | Geodo macros are heavily obfuscated with junk functions and string substitutions. [[1]](#1)|


References
----------
<a name="1">[1]</a> https://cofense.com/recent-geodo-malware-campaigns-feature-heavily-obfuscated-macros/



|||
|----|-----|
|**id**|Bxxx|
|**Name**|***Executable Code Obfuscation***|
|**Objective**|Anti-behavioral Analysis, Defense Evasion|
|**Related ATT&CK Technique(s)**||
|**Description**|Executable code can be obfuscated to hinder analysis. For example, code encryption (on disk and/or in memory); entry point, import address, or symbolic obfuscation; splitting code into rearranged sections connected by unconditional jumps, and merging all sections can make disassembly and static analysis more difficult.<br>A packer stub can generate polymorphic code on the fly, creating a file with the same functionality but different execution, making it difficult to detect.|
|**Methods**| <ul><li>Code Encryption: Encryption of the code in the malware instance in order to hinder static analysis.</li><li>Entry Point Obfuscation: Obfuscation of the entry point of the malware executable, in order to hinder static analysis.</li><li>Instruction Overlap: Jumping after the first byte of an instruction confuses some disassemblers.</li><li>Import Address Table Obfuscation: Obfuscation of the import address table of the malware instance, in order to hinder static analysis.</li><li>Symbolic Obfuscation: The removing or renaming of textual information in the code of the malware instance, in order to hinder static analysis.</li><li>Interleaving Code: A form of obfuscation that splits code into sections that are rearranged and connected by unconditional jumps, in order to hinder static analysis and disassembly.</li><li>Merged Code Sections: Merge all sections; just one entry in the sections table. Only affects readability slightly, so may not even be worth mitigating. May affect some detection signatures if written to be section dependent.</li><li>Import Compression: Imports are stored and loaded with a more compact import table format. Each DLL needed by the executable is mentioned in the IAT, but only one function from each/most is imported; the rest are imported "manually" via GetProcAddress calls.</li><li>Stack Strings: Strings are built and decrypted on the stack at each use, then discarded (to avoid obvious references).</li><li>Imports By Hash: Instead of calling GetProcAddress, a DLL is loaded and each export name is parsed until it matches a specific hash. This example is also known as GET_APIS_WITH_CRC. Also often seen used by shellcode, as it reduces the size of each import from a human-readable string to a sequence of four bytes.</li></ul>
|**Examples**|<ul><li>Ursnif: https://securityintelligence.com/news/banking-trojan-uses-malware-macros-to-evade-sandbox-detection/</li><li>Terminator: https://www.fireeye.com/content/dam/fireeye-www/current-threats/pdfs/pf/file/fireeye-hot-knives-through-butter.pdf</li><li>Kelihos: https://www.fireeye.com/content/dam/fireeye-www/current-threats/pdfs/pf/file/fireeye-hot-knives-through-butter.pdf</li><li>Rebhip: https://www.fireeye.com/blog/threat-research/2011/01/the-dead-giveaways-of-vm-aware-malware.html</li></ul>|

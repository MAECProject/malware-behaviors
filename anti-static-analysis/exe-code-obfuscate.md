|||
|---------|------------------------|
|**ID**|**E1027**|
|**Objective(s)**| [Anti-Static Analysis](https://github.com/MAECProject/malware-behaviors/tree/master/anti-static-analysis)|
|**Related ATT&CK Technique(s)**|[Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027)|


Executable Code Obfuscation
===========================
Executable code can be obfuscated to hinder disassembly and static code analysis. Methods related to anti-static analysis are below. The Executable Code Obfuscation behavior is specific to executable code; for  obfuscation of general files and information, see ATT&CK: [**Obfuscated Files or Information**](https://attack.mitre.org/techniques/T1027/).

Methods
-------
* **Code Encryption in File**: Malware code is encrypted to hinder static analysis.
* **Guard Pages**: Encrypt blocks of code individually and decrypt temporarily only upon execution.
* **Entry Point Obfuscation**: Obfuscate the entry point of the malware executable.
* **Data Value Obfuscation**: Obfuscate data values through indirection of local or global variables. For example, the instruction *if (a == 0) do x* can be obfuscated by setting a global variable, *Z*, to zero and using it in the instruction: *if (a==Z) do x*.  [NEEDS REVIEW]
* **Instruction Overlap**: Jump after the first byte of an instruction to confuse disassembler.
* **Import Address Table Obfuscation**: Obfuscate the import address table.
* **Symbol Obfuscation**: Remove or rename symbolic information commonly inserted by compilers for debugging purposes.
* **Interleaving Code**: Split code into sections that may be rearranged and are connected by unconditional jumps.
* **Merged Code Sections**: Merge all sections resulting in just one entry in the sections table to make readability more difficult. May affect some detection signatures if written to be section dependent.
* **Import Compression**: Store and load imports with a compact import table format. Each DLL needed by the executable is mentioned in the IAT, but only one function from each/most is imported; the rest are imported via GetProcAddress calls.
* **Stack Strings**: Build and decrypt strings on the stack at each use, then discard to avoid obvious references.
* **Imports By Hash**: Instead of calling GetProcAddress, a DLL is loaded and each export name is parsed until it matches a specific hash. Also known as GET_APIS_WITH_CRC. Often used by shellcode because it reduces the size of each import from a human-readable string to a sequence of four bytes.
* **Code Insertion**: Insert code to impede disassembly.
   * *Dead Code Insertion*: Include "dead" code with no real functionality.
   * *Fake Code Insertion*: Add fake code similar to known packers or known goods to fool identification. Can confuse some automated unpackers.
   * *Jump Insertion*: Insert jumps to make analysis visually harder.
   * *Thunk Code Insertion*: Variation on Jump Insertion. Used by some compilers for user-generated functions.
   * *Junk Code Insertion*: Insert dummy code between relevant opcodes. Can make signature writing more complex.
   
Malware Examples
----------------
|Name|Date|Description|
|-----------------------------|--------|-----------------------------|
|[**Geodo**](https://github.com/MAECProject/malware-behaviors/blob/master/xample-malware/geodo.md) |August 2018| Geodo macros are heavily obfuscated with junk functions and string substitutions. [[1]](#1)|

References
----------
<a name="1">[1]</a> https://cofense.com/recent-geodo-malware-campaigns-feature-heavily-obfuscated-macros/